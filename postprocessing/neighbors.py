#!/usr/bin/env python

import os
import sys
import numpy
import atooms.trajectory as trj

class Limited(object):

    # TODO: refactor it as get_neighbors

    """Limit the number of neighbors"""

    def __new__(cls, component, max_neighbors):
        cls = type('Limited', (Limited, component.__class__), component.__dict__)
        return object.__new__(cls)

    def __init__(self, component, max_neighbors=None):
        self.max_neighbors = max_neighbors

    def read_sample(self, sample):
        s = super(Limited, self).read_sample(sample)
        if self.max_neighbors is not None:
            for i in range(len(s.neighbors)):
                numn = len(s.neighbors[i])
                s.neighbors[i] = s.neighbors[i][0:min(self.max_neighbors, numn)]
        return s

def get_neighbors(f, args, tag):
    if len(args.neigh_file) == 0:
        cmd = 'neigh.x -p %s %s %s' % (tag, args.neigh, f)
        os.system(cmd)
        # That is the file generated by neigh.x
        fn = f + '%s.neigh' % tag
        tn = trj.TrajectoryNeighbors(fn)
        desc = cmd
    else:
        from atooms.plugins.voronoi import TrajectoryVoronoi
        # TODO: is we ever get to make this a clean factory, test can be avoided
        if args.neigh_voronoi:
            from atooms.plugins.voronoi import TrajectoryVoronoi
            tn = TrajectoryVoronoi(args.neigh_file)
        else:
            tn = trj.TrajectoryNeighbors(args.neigh_file)
        desc = args.neigh_file
    if args.neigh_limit is not None:
        tnl = Limited(tn, args.neigh_limit)
    else:
        tnl = tn
    return tnl, desc

def all_neighbors(s):
    neigh = []
    for i, pi in enumerate(s.particle):
        nn = numpy.array([j for j in range(len(s.particle)) if i != j])
        neigh.append(nn)
    return neigh

def main(t, kcut=1.0):
    for s in t:
        npart = len(s.particle)
        for i in range(npart):
            for j in range(npart):
                if i <= j: continue
                dr = s.particle[i].distance(s.particle[j], s.cell)
                if numpy.sqrt(numpy.dot(dr,dr)) < kcut:
                    print i, j

if __name__ == '__main__':    
    main(trj.TrajectoryXYZ(sys.argv[1]))
    
